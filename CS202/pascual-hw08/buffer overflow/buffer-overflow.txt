a vulnerable function that declares a buffer on the stack and writes into it;
an innocent bystander function;
and a main() that calls the vulnerable function.

You must devise a stream of bytes that, when the vulnerable function writes them into its local, stack-allocated
buffer, results in the return address in the vulnerable function's stack frame being replaced with an address
inside the innocent bystander function.


In the source data in your call to memcpy(), you will likely want to include non-printable ASCII characters.
You can specify these in a C string using the syntax "\x12", which represents the raw byte 0x12.
Thus an alternate way to specify the string "hello" is "\x68\x65\x6c\x6c\x6f" (check the ASCII table to see why).

When you've got it working, you should observe a rather strange series of events.
Specifically, main() will call the vulnerable function. That function will copy data into its
local buffer and then return. But it won't return to main. It should "return" to the innocent
bystander function, even though that's not the caller. Then the innocent bystander function will
run to completion and attempt to return, but chances are good its own return address will be bogus
by this point and you'll just get a segfault. That's okay. The important part is that you got it to
return to the wrong place.
